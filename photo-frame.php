<?php
/**
 * Picks a specified number of random filenames from a given file.
 *
 * @param string $filepath The path to the file containing filenames.
 * @param int $count The number of random filenames to pick. Default is 7.
 * @return array An array of randomly picked filenames.
 * 
 * @summary This function reads a file line by line, ignoring empty lines,
 * and returns an array of random filenames. The file is generated by periodically running a script (via e.g. crontab)
 * that lists all files in a specific directory, ensuring that the filenames are unique and up-to-date.
 * 
 * @example $> crontab -l
 * @daily /path/to/scripts/list-pictures.sh
 * 
 * @file /path/to/scripts/list-pictures.sh
 * #!/bin/bash
 * # List all files in the specified directory and save to a text file
 * cd /path/to/pictures || exit 1
 * find . -type f ! '(' -iname '._*' -o -iname '_*' ')' '(' -name '*.jpg' -o -name '*.png' -o -name '*.gif' ')' | sort -h | uniq -u > /path/to/scripts/pictures.txt  
 * 
 */
function pickRandomFilenames($filepath, $count = 7) {
    if (!file_exists($filepath) || !is_readable($filepath)) {
        return [];
    }

    $lines = file($filepath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
    if (empty($lines)) {
        return [];
    }

    $total = count($lines);
    if ($count > $total) {
        $count = $total;
    }

    $randomKeys = array_rand($lines, $count);
    // array_rand returns a single int if $count == 1
    if ($count === 1) {
        return [$lines[$randomKeys]];
    }
    $result = [];
    foreach ($randomKeys as $key) {
        $result[] = $lines[$key];
    }
    return $result;
}

/**
 * Generates a random integer between min (inclusive) and max (exclusive).
 *
 * @param int $min The minimum value (inclusive).
 * @param int $max The maximum value (inclusive).
 * @return int A random integer between min and max.
 */
use function mt_rand as rnd;


/**
 * Extracts a date from a filename and formats it to a human-readable string.
 * The date is expected to be in the format 'YYYY-MM-DD'.
 *
 * @param string $filename The filename containing a date.
 * @return string A formatted date string in 'ro-RO' locale, or an empty string if no valid date is found.
 */
$dateRegexp = '/(\d{4}-\d{2}-\d{2})/';

function getDateFromFilename($filename) {
    global $dateRegexp;
    if (preg_match($dateRegexp, $filename, $matches) === false) {
        return '';
    }
    $dateStr = $matches[0];
    $d = DateTime::createFromFormat('Y-m-d', $dateStr);
    if ($d === false) {
        return '';
    }
    // Romanian month names
    $months = [
        1 => 'ianuarie',
        2 => 'februarie',
        3 => 'martie',
        4 => 'aprilie',
        5 => 'mai',
        6 => 'iunie',
        7 => 'iulie',
        8 => 'august',
        9 => 'septembrie',
        10 => 'octombrie',
        11 => 'noiembrie',
        12 => 'decembrie'
    ];
    $day = (int)$d->format('j');
    $month = (int)$d->format('n');
    $year = $d->format('Y');
    return "{$day} {$months[$month]} {$year}";
}

/**
 * Constructs the image path.
 * @param string $filePath The received file path.
 * @return string The full image path.
 */
function getPathFromFilename($filePath) {
    $prefix = '/sabina';
    $dateParts = explode('/', $filePath);
    if (strpos($dateParts[0], '.') === 0) {
        $dateParts[0] = $prefix;
    } else {
        array_unshift($dateParts, $prefix);
    }
    return implode('/', $dateParts);
}

/**
 * Extracts the label from a filename, which includes the date and any additional text.
 * @param string $path The filename to extract the label from.
 * @return string A formatted label string.
 */
function getLabelFromFilename($path) {
    // Get the filename without path and extension
    $fileName = pathinfo($path, PATHINFO_FILENAME);

    // Get the date from filename
    $date = getDateFromFilename($path);

    // Remove non-letters and spaces, then trim
    $strippedName = trim(preg_replace('/[^a-zA-Z\s]/', '', $fileName));

    if (strlen($strippedName) > 3) {
        $date = $date . ' „' . $strippedName . '”';
    }
    return $date;
}

/**
 * Creates an HTML image element with the source set to the path received.
 * @param string $filePath The file path to be used for the image source.
 * @return string HTML <img> element with the specified source and alt text.
 */
function createImageElement($filePath) {
    $alt = htmlspecialchars(getDateFromFilename($filePath), ENT_QUOTES | ENT_HTML5, 'UTF-8');
    $src = htmlspecialchars(getPathFromFilename($filePath), ENT_QUOTES | ENT_HTML5, 'UTF-8');
    return '<img src="' . $src . '" alt="' . $alt . '">';
}

/**
 * Creates a label element displaying the date extracted from the filename.
 * @param string $filename The filename to extract the date from.
 * @return string HTML <label> element with the formatted date text.
 */
function createImageLabel($filename) {
    if (trim($filename) === '') {
        // Optionally log or handle empty filename
        return '';
    }
    $labelText = getLabelFromFilename($filename);
    $safeLabel = htmlspecialchars($labelText, ENT_QUOTES | ENT_HTML5, 'UTF-8');
    return '<label title="' . $safeLabel . '">' . $safeLabel . '</label>';
}

/**
 * Creates a frame element containing an image and its label.
 * @param string $filename The filename to be used for the image and label.
 * @param bool $hasLabel Whether to include the label.
 * @return string HTML for the frame with image and label.
 */
function createFrameElement($filename, $hasLabel = true) {
    $imgHtml = createImageElement($filename);
    $labelHtml = $hasLabel ? createImageLabel($filename) : '';
    return '<div class="frame">' . $imgHtml . $labelHtml . '</div>';
}

/**
 * Renders the photo frame by creating and positioning image frames based on the provided file list.
 * The first image is displayed in the front, and the rest are positioned in the backdrop.
 * @param array $files An array of filenames to be displayed in the photo frame.
 * @return string HTML markup for the frames.
 */
function render(array $files) {
    // Randomize clock position and side
    $clockTop = rand(20, 81) . '%';
    $flipSide = rand(0, 1);
    $clockClass = $flipSide ? 'right-side' : '';
    // You can echo these values in your clock element if needed

    // First image is the front image
    $frontImage = array_shift($files);

    // Create the front image frame
    $randomRotation = rand(-5, 5);
    $frontFrameHtml = createFrameElement($frontImage);
    $frontFrameStyle = "transform:translate(-50%, -50%) rotate({$randomRotation}deg);";
    // Optionally add right-side class to label if rotation < 0
    if ($randomRotation < 0) {
        $frontFrameHtml = str_replace('<label', '<label class="right-side"', $frontFrameHtml);
    }
    $frontFrameHtml = str_replace('<div class="frame">', '<div class="frame" style="' . $frontFrameStyle . '" data-rotation="' . $randomRotation . '">', $frontFrameHtml);

    // Backdrop positions
    $backdropPositions = [
        ['top' => '-20%', 'left' => '60%'],
        ['top' => '50%', 'left' => '50%'],
        ['top' => '50%', 'left' => '0'],
        ['top' => '-20%', 'left' => '-20%'],
        ['top' => '25%', 'left' => '-20%'],
        ['top' => '25%', 'left' => '70%'],
        ['top' => '-20%', 'left' => '0'],
    ];

    $backdropHtml = '';
    foreach ($files as $i => $filename) {
        $rotation = rand(-90, 90);
        $pos = $backdropPositions[$i % count($backdropPositions)];
        $style = "top:{$pos['top']};left:{$pos['left']};transform:rotate({$rotation}deg);";
        $backdropHtml .= '<div class="frame" style="' . $style . '" data-rotation="' . $rotation . '">' .
            createImageElement($filename) .
            createImageLabel($filename) .
            '</div>';
    }

    return [
        'front' => $frontFrameHtml,
        'backdrop' => $backdropHtml,
        'clockTop' => $clockTop,
        'clockClass' => $clockClass,
    ];
}


// ================ MAIN SCRIPT ================ //
// Define the path to the file containing filenames
$filenameFile = '/home/tudor/scripts/pictures.txt';
// Pick 8 random filenames from the file
$files = pickRandomFilenames($filenameFile, 8);
// Generate the HTML for the frames
$sections = render($files);
?>
<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="1800"> <!-- Refresh every 30 minutes -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="https://sabina.com.ro/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="https://sabina.com.ro/apple-touch-icon.png">
    <title>Rama foto</title>
    <style>
    html,
    body {
        background: #1e1e1e;
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        position: relative;
        font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        font-size: 120%;
        -webkit-overflow-scrolling: none;
        overscroll-behavior-y: none;
    }

    #front {
        text-align: center;
        z-index: 2;
        cursor: pointer;
    }

    .frame {
        background-color: #cfcfcf;
        border: 1.5rem solid #cfcfcf;
        border-radius: .3em;
        box-shadow: 0 0 15px rgba(0, 0, 0, .4);
        position: absolute;
        top: 50%;
        left: 50%;
        overflow: visible;
        font-size: 0
    }

    .frame label {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        transform: translateY(calc(50% + 0.7rem));
        text-align: left;
        color: #002448;
        font-size: 1rem;
        font-weight: bold;
    }

    .frame label::before,
    .frame label::after {
        content: attr(title);
        position: absolute;
        top: 0;
        left: 0;
        color: rgba(255, 255, 255, .3);
    }

    .frame label::before {
        left: 1px;
        top: 1px;
    }

    .frame label::after {
        left: 2px;
        top: 2px;
    }

    .frame label.right-side {
        text-align: right;
        right: 0;
    }

    .frame label.right-side::before,
    .frame label.right-side::after {
        text-align: right;
        right: 0;
    }

    #front .frame img {
        max-width: 90vw;
        max-height: 90vh;
    }

    #backdrop .frame {
        background-color: #53d1ff;
    }

    #backdrop .frame label {
        display: none;
    }

    #backdrop img {
        filter: grayscale(100%) contrast(110%) opacity(0.85);
        max-height: 80vh;
    }

    #clock {
        color: #fff;
        font-size: 250%;
        text-shadow: 2px 2px 5px #000;
        padding: 1rem 2rem;
        position: fixed;
        background: rgba(0, 0, 0, .6);
        border-radius: 0 1rem 1rem 0;
        user-select: none;
    }

    #clock.small {
        font-size: 2rem;
        padding: 0.5rem 1rem;
    }

    #clock.right-side {
        border-radius: 1rem 0 0 1rem;
        right: 0;
    }

    #loader {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background: rgb(30, 30, 30);
        color: rgb(163, 163, 163);
        font-size: 120%;
        display: flex;
        align-items: center;
        justify-content: center;
        -webkit-user-select: none;
        user-select: none;
        transition: opacity 0.5s ease-in-out;
    }

    #loader.hidden,
    #clock.hidden {
        opacity: 0;
        pointer-events: none;
    }
    </style>
</head>

<body>
    <div id="backdrop"><?php echo $sections['backdrop']; ?></div>
    <div id="front"><?php echo $sections['front']; ?></div>
    <div id="loader">⏳ Se încarcă imaginile...</div>
    <div id="clock" class="hidden <?php echo $sections['clockClass']; ?>"
        style="top: <?php echo $sections['clockTop']; ?>">
        <?php echo date('H:i') ?>
    </div>

    <script>
    // Hide the loader when the page is fully loaded
    window.addEventListener('load', function(ev) {
        document.getElementById('loader').classList.add('hidden');

        // Initial check
        updateClockClass();

        // Listen for changes
        iphoneQuery.addEventListener("change", updateClockClass);
        ipadQuery.addEventListener("change", updateClockClass);
    });

    // Reload the page on click
    document.getElementById('front').addEventListener('click', function(ev) {
        ev.preventDefault();
        window.location.reload();
    });

    /**
     * Updates the clock element with the current time in 'Europe/Bucharest' timezone.
     */
    function updateClock() {
        var clock = document.getElementById('clock');
        // Do not update if clock is hidden
        if (!clock || clock.classList.contains('hidden')) return;

        var nowText = new Date().toTimeString().split(':').slice(0, 2).join(':');
        if (clock.textContent !== nowText) {
            clock.textContent = nowText;
        }
    }

    // Update the clock every 5 seconds
    setInterval(updateClock, 5000);

    var iphoneQuery = window.matchMedia(
        "only screen and (min-device-width: 320px) and (max-device-width: 480px) and (-webkit-device-pixel-ratio: 2) and (device-aspect-ratio: 2/3)"
    );
    var ipadQuery = window.matchMedia(
        "only screen and (min-device-width: 768px) and (max-device-width: 1024px)"
    );
    var clockElement = document.getElementById('clock');

    function updateClockClass() {
        if (!clockElement) return;
        clockElement.classList.remove('small', 'hidden');
        if (iphoneQuery.matches) {
            clockElement.classList.add('hidden');
        } else if (ipadQuery.matches) {
            clockElement.classList.add('small');
        }
    }
    </script>
</body>

</html>
